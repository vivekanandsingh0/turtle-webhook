//+------------------------------------------------------------------+
//| PURE BREAKOUT - NO FILTER VERSION                               |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

input double LotSize = 1;

datetime lastClosedCandleTime = 0;
datetime lastTradeCandleTime  = 0;

//--------------------------------------------------------------
double NormalizeLot(double lot)
{
   double minLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   lot = MathMax(lot, minLot);
   lot = MathMin(lot, maxLot);
   lot = MathFloor(lot / lotStep) * lotStep;

   return lot;
}
//--------------------------------------------------------------
int OnInit()
{
   return(INIT_SUCCEEDED);
}
//--------------------------------------------------------------
void OnTick()
{
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   double prevHigh = iHigh(_Symbol, PERIOD_CURRENT, 1);
   double prevLow  = iLow(_Symbol, PERIOD_CURRENT, 1);

   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   double lot = NormalizeLot(LotSize);

   datetime currentCandleTime = iTime(_Symbol, PERIOD_CURRENT, 0);

   // ================= ENTRY =================
   if(!PositionSelect(_Symbol))
   {
      // Only block multiple entries in same candle
      if(currentCandleTime != lastTradeCandleTime)
      {
         // BUY if price above previous high
         if(ask > prevHigh)
         {
            double sl = NormalizeDouble(prevLow, digits);

            if(trade.Buy(lot, _Symbol, ask, sl, 0))
               lastTradeCandleTime = currentCandleTime;
         }

         // SELL if price below previous low
         if(bid < prevLow)
         {
            double sl = NormalizeDouble(prevHigh, digits);

            if(trade.Sell(lot, _Symbol, bid, sl, 0))
               lastTradeCandleTime = currentCandleTime;
         }
      }
   }

   // ================= TRAILING =================
   if(PositionSelect(_Symbol))
   {
      datetime closedTime = iTime(_Symbol, PERIOD_CURRENT, 1);

      if(closedTime != lastClosedCandleTime)
      {
         lastClosedCandleTime = closedTime;

         long type = PositionGetInteger(POSITION_TYPE);
         double tp = PositionGetDouble(POSITION_TP);

         double newPrevHigh = iHigh(_Symbol, PERIOD_CURRENT, 1);
         double newPrevLow  = iLow(_Symbol, PERIOD_CURRENT, 1);

         if(type == POSITION_TYPE_BUY)
         {
            double newSL = NormalizeDouble(newPrevLow, digits);
            trade.PositionModify(_Symbol, newSL, tp);
         }

         if(type == POSITION_TYPE_SELL)
         {
            double newSL = NormalizeDouble(newPrevHigh, digits);
            trade.PositionModify(_Symbol, newSL, tp);
         }
      }
   }
}
//+------------------------------------------------------------------+
