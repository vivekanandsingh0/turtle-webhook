//+------------------------------------------------------------------+
//| Breakout + Progressive Risk + Range Expansion Filter (Version B)|
//+------------------------------------------------------------------+
#property strict

input double BaseRiskPercent = 1.0;
input double MultiplierStep  = 0.3;
input double MaxMultiplier   = 2.0;
input int    MaxSLReset      = 7;
input int    Slippage        = 20;

input int RangePeriod = 20;     // 20-period range
input int AvgPeriod   = 50;     // 50-period average range

int    sl_streak = 0;
double current_multiplier = 1.0;
datetime last_bar_time = 0;

//+------------------------------------------------------------------+
bool RangeExpansion()
{
   if(Bars(_Symbol,_Period) < AvgPeriod + 5)
      return false;

   // --- Calculate 20 period range
   double highest = -DBL_MAX;
   double lowest  = DBL_MAX;

   for(int i=1; i<=RangePeriod; i++)
   {
      double high = iHigh(_Symbol,_Period,i);
      double low  = iLow(_Symbol,_Period,i);

      if(high > highest) highest = high;
      if(low  < lowest)  lowest  = low;
   }

   double range20 = highest - lowest;

   // --- Calculate 50 period average range
   double sum_range = 0;

   for(int i=1; i<=AvgPeriod; i++)
   {
      double high = iHigh(_Symbol,_Period,i);
      double low  = iLow(_Symbol,_Period,i);
      sum_range += (high - low);
   }

   double avg_range50 = sum_range / AvgPeriod;

   if(range20 > avg_range50)
      return true;

   return false;
}

//+------------------------------------------------------------------+
double CalculateLot(double sl_price,double entry_price)
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double risk_amount = equity * (BaseRiskPercent/100.0) * current_multiplier;

   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);

   double sl_distance = MathAbs(entry_price - sl_price);
   if(sl_distance <= 0) return 0;

   double lot = risk_amount / ((sl_distance/tick_size) * tick_value);

   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lotStep= SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   lot = MathMax(minLot, MathMin(lot,maxLot));
   lot = NormalizeDouble(lot/lotStep,0)*lotStep;

   return lot;
}

//+------------------------------------------------------------------+
bool PositionExists()
{
   return PositionSelect(_Symbol);
}

//+------------------------------------------------------------------+
void UpdateRiskAfterClose(double profit)
{
   if(profit > 0)
   {
      sl_streak = 0;
      current_multiplier = 1.0;
   }
   else
   {
      sl_streak++;

      if(sl_streak >= MaxSLReset)
      {
         sl_streak = 0;
         current_multiplier = 1.0;
      }
      else
      {
         current_multiplier =
            MathMin(1.0 + sl_streak * MultiplierStep, MaxMultiplier);
      }
   }
}

//+------------------------------------------------------------------+
void PlaceTrade(bool buy,double sl_price)
{
   double price = buy ? SymbolInfoDouble(_Symbol,SYMBOL_ASK)
                      : SymbolInfoDouble(_Symbol,SYMBOL_BID);

   double lot = CalculateLot(sl_price,price);
   if(lot <= 0) return;

   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);

   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type   = buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   request.price  = price;
   request.sl     = sl_price;
   request.deviation = Slippage;
   request.type_filling = ORDER_FILLING_IOC;

   if(!OrderSend(request,result))
      Print("OrderSend failed: ",GetLastError());
}

//+------------------------------------------------------------------+
void TrailStop()
{
   if(!PositionSelect(_Symbol)) return;

   double prev_high = iHigh(_Symbol,_Period,1);
   double prev_low  = iLow(_Symbol,_Period,1);

   ulong ticket = (ulong)PositionGetInteger(POSITION_TICKET);
   double current_sl = PositionGetDouble(POSITION_SL);
   long type = PositionGetInteger(POSITION_TYPE);

   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);

   request.action = TRADE_ACTION_SLTP;
   request.position = ticket;

   if(type == POSITION_TYPE_BUY)
   {
      if(prev_low > current_sl)
      {
         request.sl = prev_low;
         OrderSend(request,result);
      }
   }
   else if(type == POSITION_TYPE_SELL)
   {
      if(current_sl == 0 || prev_high < current_sl)
      {
         request.sl = prev_high;
         OrderSend(request,result);
      }
   }
}

//+------------------------------------------------------------------+
void OnTick()
{
   datetime current_bar = iTime(_Symbol,_Period,0);

   if(current_bar != last_bar_time)
   {
      last_bar_time = current_bar;

      if(PositionExists())
         TrailStop();
   }

   if(PositionExists()) return;

   // ðŸ”¥ Range Expansion Regime Filter
   if(!RangeExpansion()) return;

   double prev_high = iHigh(_Symbol,_Period,1);
   double prev_low  = iLow(_Symbol,_Period,1);

   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);

   if(bid > prev_high)
      PlaceTrade(true,prev_low);
   else if(bid < prev_low)
      PlaceTrade(false,prev_high);
}

//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& request,
                        const MqlTradeResult& result)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal_ticket = trans.deal;

      if(HistoryDealSelect(deal_ticket))
      {
         long deal_entry =
            HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);

         double deal_profit =
            HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);

         if(deal_entry == DEAL_ENTRY_OUT)
            UpdateRiskAfterClose(deal_profit);
      }
   }
}
