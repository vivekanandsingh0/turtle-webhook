//+------------------------------------------------------------------+
//| Breakout + Progressive Risk + ATR Expansion Filter EA (MQL5)    |
//+------------------------------------------------------------------+
#property strict

input double BaseRiskPercent = 1.0;
input double MultiplierStep  = 0.3;
input double MaxMultiplier   = 2.0;
input int    MaxSLReset      = 7;
input int    Slippage        = 20;

input int ATR_Period = 14;
input int ATR_Consecutive = 3;

int    sl_streak = 0;
double current_multiplier = 1.0;
datetime last_bar_time = 0;

int atr_handle;

//+------------------------------------------------------------------+
int OnInit()
{
   atr_handle = iATR(_Symbol, _Period, ATR_Period);

   if(atr_handle == INVALID_HANDLE)
   {
      Print("Failed to create ATR handle");
      return(INIT_FAILED);
   }

   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
bool ATRExpansion()
{
   double atr_values[];
   ArraySetAsSeries(atr_values,true);

   int bars_needed = ATR_Consecutive + 2;

   if(CopyBuffer(atr_handle,0,0,bars_needed,atr_values) <= 0)
      return false;

   for(int i=1; i<=ATR_Consecutive; i++)
   {
      if(atr_values[i] <= atr_values[i+1])
         return false;
   }

   return true;
}

//+------------------------------------------------------------------+
double CalculateLot(double sl_price,double entry_price)
{
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double risk_amount = equity * (BaseRiskPercent/100.0) * current_multiplier;

   double tick_value = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);

   double sl_distance = MathAbs(entry_price - sl_price);
   if(sl_distance <= 0) return 0;

   double lot = risk_amount / ((sl_distance/tick_size) * tick_value);

   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double lotStep= SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   lot = MathMax(minLot, MathMin(lot,maxLot));
   lot = NormalizeDouble(lot/lotStep,0)*lotStep;

   return lot;
}

//+------------------------------------------------------------------+
bool PositionExists()
{
   return PositionSelect(_Symbol);
}

//+------------------------------------------------------------------+
void UpdateRiskAfterClose(double profit)
{
   if(profit > 0)
   {
      sl_streak = 0;
      current_multiplier = 1.0;
   }
   else
   {
      sl_streak++;

      if(sl_streak >= MaxSLReset)
      {
         sl_streak = 0;
         current_multiplier = 1.0;
      }
      else
      {
         current_multiplier = MathMin(1.0 + sl_streak * MultiplierStep,
                                      MaxMultiplier);
      }
   }
}

//+------------------------------------------------------------------+
void PlaceTrade(bool buy,double sl_price)
{
   double price = buy ? SymbolInfoDouble(_Symbol,SYMBOL_ASK)
                      : SymbolInfoDouble(_Symbol,SYMBOL_BID);

   double lot = CalculateLot(sl_price,price);
   if(lot <= 0) return;

   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);

   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = lot;
   request.type   = buy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   request.price  = price;
   request.sl     = sl_price;
   request.deviation = Slippage;
   request.type_filling = ORDER_FILLING_IOC;

   if(!OrderSend(request,result))
   {
      Print("OrderSend failed: ",GetLastError());
      return;
   }

   if(result.retcode != TRADE_RETCODE_DONE)
      Print("Order failed: ",result.retcode);
}

//+------------------------------------------------------------------+
void TrailStop()
{
   if(!PositionSelect(_Symbol)) return;

   double prev_high = iHigh(_Symbol,_Period,1);
   double prev_low  = iLow(_Symbol,_Period,1);

   ulong ticket = (ulong)PositionGetInteger(POSITION_TICKET);
   double current_sl = PositionGetDouble(POSITION_SL);
   long type = PositionGetInteger(POSITION_TYPE);

   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);

   request.action = TRADE_ACTION_SLTP;
   request.position = ticket;

   if(type == POSITION_TYPE_BUY)
   {
      if(prev_low > current_sl)
      {
         request.sl = prev_low;
         if(!OrderSend(request,result))
            Print("Modify SL failed: ",GetLastError());
      }
   }
   else if(type == POSITION_TYPE_SELL)
   {
      if(current_sl == 0 || prev_high < current_sl)
      {
         request.sl = prev_high;
         if(!OrderSend(request,result))
            Print("Modify SL failed: ",GetLastError());
      }
   }
}

//+------------------------------------------------------------------+
void OnTick()
{
   datetime current_bar = iTime(_Symbol,_Period,0);

   if(current_bar != last_bar_time)
   {
      last_bar_time = current_bar;

      if(PositionExists())
         TrailStop();
   }

   if(PositionExists()) return;

   // ðŸ”¥ ATR regime filter
   if(!ATRExpansion()) return;

   double prev_high = iHigh(_Symbol,_Period,1);
   double prev_low  = iLow(_Symbol,_Period,1);

   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);

   if(bid > prev_high)
      PlaceTrade(true,prev_low);
   else if(bid < prev_low)
      PlaceTrade(false,prev_high);
}

//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& request,
                        const MqlTradeResult& result)
{
   if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal_ticket = trans.deal;

      if(HistoryDealSelect(deal_ticket))
      {
         long deal_entry = HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
         double deal_profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);

         if(deal_entry == DEAL_ENTRY_OUT)
            UpdateRiskAfterClose(deal_profit);
      }
   }
}
